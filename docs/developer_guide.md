# LSQL Developer Guide

This guide provides a detailed overview of the LSQL project architecture, helping new contributors understand how the various components work together.

## Project Architecture

LSQL follows a modular architecture with clear separation of concerns:

```
src/
├── parser/       # Query parsing logic
│   ├── mod.rs    # Parser implementation
│   └── lsql.pest # PEST grammar definition
├── fs.rs         # File system operations
├── display.rs    # Output formatting
├── cli.rs        # Command-line interface
└── main.rs       # Entry point
```

## Module Responsibilities

### Parser Module (`src/parser/`)

The parser module is responsible for:

1. Defining the SQL-like grammar for LSQL queries (`lsql.pest`)
2. Parsing user input strings into structured query objects (`mod.rs`)
3. Representing the query structure and its components (enums, structs)

Key components:
- `LSQLParser`: The main struct for parsing, generated by PEST
- `SelectionType`: Enum for different types of selection (All, Files, Directories)
- `ComparisonOperator`: Enum for different comparison operations (Equal, NotEqual, etc.)
- `ConditionNode`: Tree structure for representing complex conditions with AND/OR logic
- `Query`: Struct holding the parsed query data

Example flow:
1. User input: `select * from . where size > "10mb";`
2. `LSQLParser::parse_query()` processes this string using the PEST grammar
3. Returns a `Query` object with selection = All, path = ".", and a condition for size > 10mb

### File System Module (`src/fs.rs`)

This module handles:

1. Interacting with the file system to list files and directories
2. Applying query filters to the file system entries
3. Evaluating conditions against file attributes

Key components:
- `FSEntry`: Struct representing a file or directory with all its attributes
- `list_entries()`: Main function for listing entries according to query parameters
- Condition evaluation methods in `FSEntry` for applying filters
- Utility functions for file metadata handling

Example flow:
1. Receive parsed query parameters
2. Use WalkDir to traverse directories (recursively or not)
3. Convert each entry to an `FSEntry` with all metadata
4. Apply condition filters from the query
5. Return filtered list of entries

### Display Module (`src/display.rs`)

This module is responsible for:

1. Formatting query results for display
2. Creating tables with appropriate columns
3. Adding color and formatting to the output

Key components:
- `display_entries()`: Main function for formatting entries into a table
- `format_size()`: Helper for human-readable file sizes
- Table creation and styling utilities

Example flow:
1. Receive filtered list of `FSEntry` objects
2. Determine which columns to display based on query
3. Format each entry's data appropriately (size, dates, etc.)
4. Create a formatted table with headers
5. Return the complete formatted string

### CLI Module (`src/cli.rs`)

This module provides:

1. Command-line argument parsing
2. The interactive shell functionality
3. High-level coordination between other modules

Key components:
- `Args`: Struct for command-line arguments (using clap)
- `CLI`: Main struct implementing the application logic
- `execute_query()`: Central method that ties everything together
- `run_interactive_shell()`: Method for the interactive mode

Example flow:
1. Parse command-line arguments
2. Set up environment (logging, colorization)
3. Execute query or start interactive shell
4. Coordinate between parser, file system, and display modules

## Data Flow

Here's how data flows through the application when executing a query:

1. **User Input**
   - CLI receives query string from command line or interactive shell

2. **Parsing**
   - `LSQLParser::parse_query()` parses the string into a structured `Query` object
   - Grammar rules are applied to validate and interpret the query

3. **File System Operations**
   - `fs::list_entries()` uses the parsed query to search the file system
   - Filters entries based on query conditions
   - Returns a list of matching `FSEntry` objects

4. **Display Formatting**
   - `display::display_entries()` formats the results into a pretty table
   - Applies color and formatting as needed

5. **Output**
   - CLI displays the formatted results to the user

## Adding New Features

When adding new features, you'll typically need to modify several parts of the codebase:

1. **Grammar**: Update `lsql.pest` with new syntax rules
2. **Parsing**: Extend `mod.rs` to parse the new syntax into structured data
3. **Implementation**: Add the functionality to interpret and execute the new feature
4. **Display**: Update the display module if the feature changes the output format

See [CONTRIBUTING.md](../CONTRIBUTING.md) for specific examples of how to add new features.

## Logging

LSQL uses the `log` crate for structured logging. When developing, use appropriate log levels:

- `error!`: For critical errors that prevent functionality
- `warn!`: For concerning but non-fatal issues
- `info!`: For general information about program execution
- `debug!`: For detailed information useful for debugging
- `trace!`: For extremely detailed tracing information

Example:

```rust
// Good logging practice
debug!("Parsing query: {}", query_str);
// Later in the code
if let Err(e) = some_operation() {
    error!("Operation failed: {}", e);
    return Err(e);
}
```

## Error Handling

LSQL uses Rust's `Result` type for error handling. Guidelines:

1. Propagate errors up with meaningful context
2. Log errors at appropriate levels
3. Avoid unwrapping Options or Results without proper handling
4. Use descriptive error messages

Example:

```rust
fn some_function() -> Result<(), String> {
    let file = match fs::metadata(path) {
        Ok(meta) => meta,
        Err(e) => {
            warn!("Failed to get metadata: {}", e);
            return Err(format!("Failed to access file: {}", e));
        }
    };
    
    // ...
    Ok(())
}
```

## Testing

LSQL uses Rust's built-in testing framework:

1. **Unit Tests**: Located within each module in a `tests` submodule
2. **Integration Tests**: Can be added in a `tests` directory at the project root

When adding new features, always add appropriate tests to verify functionality.

## Performance Considerations

- File system operations are relatively expensive - minimize them when possible
- For large directories, consider lazy evaluation or pagination
- Be mindful of memory usage when dealing with large file lists

## Common Patterns

### Adding a New Condition Type

1. Add to the `identifier` rule in the grammar
2. Add a field to `FSEntry` if needed
3. Add a case to the `evaluate_single_condition` method in `FSEntry`
4. Add appropriate tests

### Adding a New Command Option

1. Add the option to the `Args` struct in `cli.rs`
2. Add handling in the `run` method
3. Implement the functionality
4. Document in README and help text

## Additional Resources

- [PEST Documentation](https://pest.rs/)
- [clap Documentation](https://docs.rs/clap/latest/clap/)
- [Rust Book](https://doc.rust-lang.org/book/) 